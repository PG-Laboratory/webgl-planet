export default "#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec4 mod289(vec4 x){\n    return x-floor(x*(1./289.))*289.;\n}\n\nfloat mod289(float x){\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 permute(vec4 x){\n    return mod289(((x*34.)+10.)*x);\n}\n\nfloat permute(float x){\n    return mod289(((x*34.)+10.)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r){\n    return 1.79284291400159-.85373472095314*r;\n}\n\nfloat taylorInvSqrt(float r){\n    return 1.79284291400159-.85373472095314*r;\n}\n\nvec4 grad4(float j,vec4 ip){\n    const vec4 ones=vec4(1.,1.,1.,-1.);\n    vec4 p,s;\n    \n    p.xyz=floor(fract(vec3(j)*ip.xyz)*7.)*ip.z-1.;\n    p.w=1.5-dot(abs(p.xyz),ones.xyz);\n    s=vec4(lessThan(p,vec4(0.)));\n    p.xyz=p.xyz+(s.xyz*2.-1.)*s.www;\n    \n    return p;\n}\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4.309016994374947451\n\nfloat snoise(vec4 v){\n    const vec4 C=vec4(.138196601125011,// (5 - sqrt(5))/20  G4\n    .276393202250021,// 2 * G4\n    .414589803375032,// 3 * G4\n-.447213595499958);// -1 + 4 * G4\n\n// First corner\nvec4 i=floor(v+dot(v,vec4(F4)));\nvec4 x0=v-i+dot(i,C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\nvec4 i0;\nvec3 isX=step(x0.yzw,x0.xxx);\nvec3 isYZ=step(x0.zww,x0.yyz);\n//  i0.x = dot( isX, vec3( 1.0 ) );\ni0.x=isX.x+isX.y+isX.z;\ni0.yzw=1.-isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\ni0.y+=isYZ.x+isYZ.y;\ni0.zw+=1.-isYZ.xy;\ni0.z+=isYZ.z;\ni0.w+=1.-isYZ.z;\n\n// i0 now contains the unique values 0,1,2,3 in each channel\nvec4 i3=clamp(i0,0.,1.);\nvec4 i2=clamp(i0-1.,0.,1.);\nvec4 i1=clamp(i0-2.,0.,1.);\n\n//  x0 = x0 - 0.0 + 0.0 * C.xxxx\n//  x1 = x0 - i1  + 1.0 * C.xxxx\n//  x2 = x0 - i2  + 2.0 * C.xxxx\n//  x3 = x0 - i3  + 3.0 * C.xxxx\n//  x4 = x0 - 1.0 + 4.0 * C.xxxx\nvec4 x1=x0-i1+C.xxxx;\nvec4 x2=x0-i2+C.yyyy;\nvec4 x3=x0-i3+C.zzzz;\nvec4 x4=x0+C.wwww;\n\n// Permutations\ni=mod289(i);\nfloat j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);\nvec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.))+i.z+vec4(i1.z,i2.z,i3.z,1.))+i.y+vec4(i1.y,i2.y,i3.y,1.))+i.x+vec4(i1.x,i2.x,i3.x,1.));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\nvec4 ip=vec4(1./294.,1./49.,1./7.,0.);\n\nvec4 p0=grad4(j0,ip);\nvec4 p1=grad4(j1.x,ip);\nvec4 p2=grad4(j1.y,ip);\nvec4 p3=grad4(j1.z,ip);\nvec4 p4=grad4(j1.w,ip);\n\n// Normalise gradients\nvec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\np0*=norm.x;\np1*=norm.y;\np2*=norm.z;\np3*=norm.w;\np4*=taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\nvec3 m0=max(.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.);\nvec2 m1=max(.6-vec2(dot(x3,x3),dot(x4,x4)),0.);\nm0=m0*m0;\nm1=m1*m1;\nreturn 49.*(dot(m0*m0,vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2)))+dot(m1*m1,vec2(dot(p3,x3),dot(p4,x4))));\n\n}\n\n"